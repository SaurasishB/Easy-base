package ${entity.packageName}.service;

import ${entity.packageName}.model.${entity.entity};
import ${entity.packageName}.model.${entity.entity}Impl;
<#-- Import enums -->
<#list entity.fields as field>
<#if field.isEnum()>
import ${entity.packageName}.model.enums.${field.enumClass};
</#if>
</#list>
<#-- Import relationship targets -->
<#list entity.fields as field>
<#if field.isRelationship() && field.targetPackage?? && field.targetPackage?has_content>
import ${field.targetPackage}.${field.target};
</#if>
</#list>
import ${entity.packageName}.repository.${entity.entity}Repository;
import ${entity.packageName}.web.dto.${entity.entity}RequestDTO;
import ${entity.packageName}.web.dto.${entity.entity}ResponseDTO;

import com.easybase.core.collection.CollectionService;
import com.easybase.core.sync.SyncService;
import com.easybase.common.exception.EntityNotFoundException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
<#list entity.requiredImports as import>
import ${import};
</#list>


/**
* Service implementation for ${entity.entity} operations.
* Generated by EasyBase Code Generator.
*/
@Service
@Transactional
public class ${entity.entity}ServiceImpl implements ${entity.entity}Service {

private final ${entity.entity}Repository repository;
private final CollectionService collectionService;
private final SyncService syncService;

@Autowired
public ${entity.entity}ServiceImpl(
${entity.entity}Repository repository,
CollectionService collectionService,
SyncService syncService) {
this.repository = repository;
        this.collectionService = collectionService;
        this.syncService = syncService;
    }

    @Override
    public ${entity.entity}ResponseDTO create(${entity.entity}RequestDTO requestDTO) {
// Create the entity from the request DTO
${entity.entity} entity = new ${entity.entity}Impl();
        updateEntityFromDTO(entity, requestDTO);

        // Save the entity
        ${entity.entity} savedEntity = repository.save(entity);

        // Synchronize with Elasticsearch
        syncService.syncRecord("${entity.table}", savedEntity);

        return convertToResponseDTO(savedEntity);
    }

    @Override
    public ${entity.entity}ResponseDTO update(${entity.getPrimaryKeyField().javaType} id, ${entity.entity}RequestDTO requestDTO) {
// Find the existing entity
${entity.entity} entity = repository.findById(id)
.orElseThrow(() -> new EntityNotFoundException("${entity.entity} not found with ID: " + id));

// Update the entity from the request DTO
updateEntityFromDTO(entity, requestDTO);

// Save the updated entity
${entity.entity} savedEntity = repository.save(entity);

        // Synchronize with Elasticsearch
        syncService.syncRecord("${entity.table}", savedEntity);

        return convertToResponseDTO(savedEntity);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<${entity.entity}ResponseDTO> findById(${entity.getPrimaryKeyField().javaType} id) {
return repository.findById(id)
.map(this::convertToResponseDTO);
}

    @Override
    @Transactional(readOnly = true)
    public Page<${entity.entity}ResponseDTO> findAll(Pageable pageable) {
return repository.findAll(pageable)
.map(this::convertToResponseDTO);
}

    @Override
    public boolean deleteById(${entity.getPrimaryKeyField().javaType} id) {
if (!repository.existsById(id)) {
return false;
}

        repository.deleteById(id);

        // Synchronize deletion with Elasticsearch
        syncService.deleteRecord("${entity.table}", id.toString());

        return true;
    }

    @Override
    @Transactional(readOnly = true)
    public Page<${entity.entity}ResponseDTO> search(String search, String filter, String sort, Pageable pageable) {
return collectionService.search("${entity.table}", search, filter, sort, pageable)
.map(this::convertToResponseDTO);
}

    /**
     * Updates an entity from a request DTO.
     *
     * @param entity The entity to update
     * @param dto The DTO containing the updated data
     */
    private void updateEntityFromDTO(${entity.entity} entity, ${entity.entity}RequestDTO dto) {
<#list entity.fields as field>
<#if !field.isPrimaryKey() && !field.isRelationship()>
entity.set${field.name?cap_first}(dto.get${field.name?cap_first}());
        </#if>
        </#list>

        <#-- Handle relationships -->
        <#list entity.fields as field>
        <#if field.isRelationship()>
        // TODO: Handle ${field.name} relationship
        </#if>
        </#list>
    }

    /**
     * Converts an entity to a response DTO.
     *
     * @param entity The entity to convert
     * @return The response DTO
     */
    private ${entity.entity}ResponseDTO convertToResponseDTO(${entity.entity} entity) {
${entity.entity}ResponseDTO dto = new ${entity.entity}ResponseDTO();

        <#list entity.fields as field>
        <#if !field.isRelationship()>
        dto.set${field.name?cap_first}(entity.get${field.name?cap_first}());
        </#if>
        </#list>

        <#-- Handle relationships -->
        <#list entity.fields as field>
        <#if field.isRelationship()>
        // TODO: Handle ${field.name} relationship
        </#if>
        </#list>

        return dto;
    }
}