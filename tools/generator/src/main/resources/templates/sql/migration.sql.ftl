-- Migration script for ${entity.entity}
-- Generated by EasyBase Code Generator

CREATE TABLE ${entity.table} (
<#list entity.fields as field>
<#if !field.isRelationship()>
${field.name} ${field.columnDefinition}<#if field.isPrimaryKey()> PRIMARY KEY</#if><#if field_has_next || entity.hasRelationships() || !entity.hasAuditFields()>,</#if>
<#elseif field.relationType == 'ManyToOne' || field.relationType == 'OneToOne'>
${field.joinColumn} VARCHAR(36) REFERENCES <#if field.targetPackage??>
<#assign targetTable = field.targetPackage?split(".")?last + "." + field.target>
${targetTable?lower_case}
<#else>
${field.target?lower_case}
</#if>(id)<#if field_has_next || !entity.hasAuditFields()>,</#if>
</#if>
</#list>
<#if !entity.hasAuditFields()>

created_date TIMESTAMP,
last_modified_date TIMESTAMP
</#if>
);

<#-- Create junction tables for ManyToMany relationships -->
<#list entity.fields as field>
<#if field.isRelationship() && field.relationType == 'ManyToMany'>
CREATE TABLE ${entity.table}_${field.target?lower_case} (
${entity.table?lower_case}_id VARCHAR(36) REFERENCES ${entity.table}(id),
<#if field.targetPackage??>
<#assign targetTable = field.targetPackage?split(".")?last + "." + field.target>
${field.target?lower_case}_id VARCHAR(36) REFERENCES ${targetTable?lower_case}(id),
<#else>
${field.target?lower_case}_id VARCHAR(36) REFERENCES ${field.target?lower_case}(id),
</#if>
PRIMARY KEY (${entity.table?lower_case}_id, ${field.target?lower_case}_id)
);
</#if>
</#list>

<#-- Create indexes for fields explicitly marked as indexed -->
<#list entity.fields as field>
<#if field.indexed?? && field.indexed && !field.isPrimaryKey() && !field.isRelationship()>
CREATE INDEX idx_${entity.table}_${field.name} ON ${entity.table}(${field.name});
</#if>
</#list>

<#-- Create indexes for relationship foreign keys -->
<#list entity.fields as field>
<#if field.isRelationship() && (field.relationType == 'ManyToOne' || field.relationType == 'OneToOne')>
CREATE INDEX idx_${entity.table}_${field.joinColumn} ON ${entity.table}(${field.joinColumn});
</#if>
</#list>

<#-- Create composite indexes for finder methods with multiple parameters -->
<#if entity.finders??>
<#list entity.finders as finder>
<#if finder.name?starts_with("findBy") || finder.name?starts_with("countBy")>
<#assign methodName = finder.name?replace("^(findBy|countBy)", "", "r")>
<#assign parts = methodName?split("And")>
<#if parts?size gt 1>
<#-- This is a multi-parameter finder - create a composite index -->
<#assign columns = "">
<#list parts as part>
<#assign fieldName = part>
<#if fieldName?has_content>
<#assign fieldName = fieldName?substring(0, 1)?lower_case + fieldName?substring(1)>
<#-- Find field that matches this name pattern -->
<#list entity.fields as field>
<#if fieldName?starts_with(field.name) && !field.isPrimaryKey() && !field.isRelationship()>
<#if columns?has_content><#assign columns = columns + ", "></#if>
<#assign columns = columns + field.name>
</#if>
</#list>
</#if>
</#list>
<#if columns?has_content>
CREATE INDEX idx_${entity.table}_${methodName?lower_case} ON ${entity.table}(${columns});
</#if>
<#else>
<#-- Single parameter finder - check if we need a simple index -->
<#assign fieldName = methodName>
<#if fieldName?has_content>
<#assign fieldName = fieldName?substring(0, 1)?lower_case + fieldName?substring(1)>
<#list entity.fields as field>
<#if fieldName?starts_with(field.name) && !field.isPrimaryKey() && !(field.indexed?? && field.indexed) && !field.isRelationship()>
CREATE INDEX idx_${entity.table}_${field.name}_finder ON ${entity.table}(${field.name});
</#if>
</#list>
</#if>
</#if>
</#if>
</#list>
</#if>