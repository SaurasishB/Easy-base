package ${entity.baseComponentPackage("service")};

import ${entity.componentPackage("model")}.${entity.name};
import ${entity.componentPackage("repository")}.${entity.name}JpaRepository;
import ${entity.componentPackage("api")}.model.dto.${entity.name}DTO;
import ${entity.componentPackage("api")}.model.dto.${entity.name}RequestDTO;
import ${entity.componentPackage("api")}.model.mapper.${entity.name}Mapper;
import com.easybase.core.sync.SyncService;
import com.easybase.common.exception.EntityNotFoundException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
<#assign primaryKey = entity.primaryKey>
<#if primaryKey?has_content>
    import ${primaryKey.get().javaType};
</#if>

/**
* Base local service implementation for ${entity.name}.
* Generated by EasyBase Code Generator.
*/
@Service
@Transactional
public class ${entity.name}BaseLocalServiceImpl implements ${entity.name}BaseLocalService {

protected final ${entity.name}JpaRepository repository;
protected final ${entity.name}Mapper mapper;
protected final SyncService syncService;

@Autowired
public ${entity.name}BaseLocalServiceImpl(
${entity.name}JpaRepository repository,
${entity.name}Mapper mapper,
SyncService syncService) {
this.repository = repository;
this.mapper = mapper;
this.syncService = syncService;
}

@Override
public ${entity.name}DTO create(${entity.name}RequestDTO requestDTO) {
${entity.name} entity = mapper.toEntity(requestDTO);
entity = repository.save(entity);

// Sync to Elasticsearch
syncService.syncRecord("${entity.fullTableName}", entity);

return mapper.toDTO(entity);
}

@Override
public ${entity.name}DTO update(<#if primaryKey?has_content>${primaryKey.get().javaType}<#else>Long</#if> id, ${entity.name}RequestDTO requestDTO) {
${entity.name} entity = repository.findById(id)
.orElseThrow(() -> new EntityNotFoundException("${entity.name}", id.toString()));

mapper.updateEntity(entity, requestDTO);
entity = repository.save(entity);

// Sync to Elasticsearch
syncService.syncRecord("${entity.fullTableName}", entity);

return mapper.toDTO(entity);
}

@Override
@Transactional(readOnly = true)
public Optional<${entity.name}DTO> findById(<#if primaryKey?has_content>${primaryKey.get().javaType}<#else>Long</#if> id) {
    <#if entity.isSoftDeleteEnabled()>
        return repository.findByIdActive(id)
        .map(mapper::toDTO);
    <#else>
        return repository.findById(id)
        .map(mapper::toDTO);
    </#if>
    }

    @Override
    @Transactional(readOnly = true)
    public Page<${entity.name}DTO> findAll(Pageable pageable) {
        <#if entity.isSoftDeleteEnabled()>
            return repository.findAllActive()
            .stream()
            .map(mapper::toDTO)
            .collect(Collectors.collectingAndThen(
            Collectors.toList(),
            list -> new org.springframework.data.domain.PageImpl<>(list, pageable, list.size())
            ));
        <#else>
            return repository.findAll(pageable)
            .map(mapper::toDTO);
        </#if>
        }

        @Override
        public boolean delete(<#if primaryKey?has_content>${primaryKey.get().javaType}<#else>Long</#if> id) {
        <#if entity.isSoftDeleteEnabled()>
            ${entity.name} entity = repository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("${entity.name}", id.toString()));

            entity.set${entity.softDeleteField?cap_first}(true);
            repository.save(entity);

            // Sync to Elasticsearch
            syncService.syncRecord("${entity.fullTableName}", entity);

            return true;
        <#else>
            if (!repository.existsById(id)) {
            return false;
            }

            repository.deleteById(id);

            // Sync deletion to Elasticsearch
            syncService.deleteRecord("${entity.fullTableName}", id.toString());

            return true;
        </#if>
        }

        <#if entity.isSoftDeleteEnabled()>
            @Override
            public boolean hardDelete(<#if primaryKey?has_content>${primaryKey.get().javaType}<#else>Long</#if> id) {
            if (!repository.existsById(id)) {
            return false;
            }

            repository.deleteById(id);

            // Sync deletion to Elasticsearch
            syncService.deleteRecord("${entity.fullTableName}", id.toString());

            return true;
            }
        </#if>

        @Override
        @Transactional(readOnly = true)
        public Page<${entity.name}DTO> search(String search, String filter, String sort, Pageable pageable) {
            // Implement search using SyncService and SearchUtil
            // This will require integration with the core search services
            throw new UnsupportedOperationException("Search not implemented yet");
            }

            <#list entity.finders as finder>
                @Override
                @Transactional(readOnly = true)
                public ${finder.methodSignature.replace(entity.name, entity.name + "DTO")} {
                // CUSTOM CODE START: ${finder.name}
                // Implement the finder method
                throw new UnsupportedOperationException("${finder.name} not implemented yet");
                // CUSTOM CODE END: ${finder.name}
                }
            </#list>

            /**
            * Validates a request DTO.
            *
            * @param requestDTO the request DTO
            * @throws IllegalArgumentException if validation fails
            */
            protected void validateRequestDTO(${entity.name}RequestDTO requestDTO) {
            // CUSTOM CODE START: validateRequestDTO
            // Add validation logic
            // CUSTOM CODE END: validateRequestDTO
            }
            }